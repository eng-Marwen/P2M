name: Version and Tag

on:
  workflow_call:
    inputs:
      service_name:
        description: 'Service name (e.g., backend, frontend)'
        required: true
        type: string
    outputs:
      version:
        description: 'The generated version number'
        value: ${{ jobs.version-and-tag.outputs.version }}
      tag:
        description: 'The generated tag name'
        value: ${{ jobs.version-and-tag.outputs.tag }}

jobs:
  version-and-tag:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for tags

      - name: Get version from Git tags
        id: version
        run: |
          # Fetch latest tags
          git fetch --tags

          # Get latest tag for this service
          LATEST_TAG=$(git tag -l "${{ inputs.service_name }}-v*" | sort -V | tail -n1)
          if [ -z "$LATEST_TAG" ]; then
            VERSION="0.0.0"
            TAG="${{ inputs.service_name }}-v$VERSION"
            echo "No existing tags found, starting at $VERSION"
          else
            # Extract version numbers
            VERSION="${LATEST_TAG#${{ inputs.service_name }}-v}"
            TAG="$LATEST_TAG"
            echo "Latest tag found: $TAG"
          fi

          # Parse version into MAJOR.MINOR.PATCH
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # Get last commit message
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "Commit message: $COMMIT_MSG"

          # Decide if bump is needed
          if echo "$COMMIT_MSG" | grep -qiE '^feat!:|BREAKING CHANGE:'; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            TAG="${{ inputs.service_name }}-v${NEW_VERSION}"
            echo "ðŸš€ Breaking change, bumping MAJOR to $NEW_VERSION"
          elif echo "$COMMIT_MSG" | grep -qiE '^feat:'; then
            MINOR=$((MINOR + 1))
            PATCH=0
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            TAG="${{ inputs.service_name }}-v${NEW_VERSION}"
            echo "âœ¨ New feature, bumping MINOR to $NEW_VERSION"
          elif echo "$COMMIT_MSG" | grep -qiE '^fix:'; then
            PATCH=$((PATCH + 1))
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            TAG="${{ inputs.service_name }}-v${NEW_VERSION}"
            echo "ðŸ› Bug fix, bumping PATCH to $NEW_VERSION"
          else
            # No bump, keep latest tag
            NEW_VERSION="$VERSION"
            echo "No version bump, keeping tag $TAG"
          fi

          # Set outputs for later steps
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo $TAG

      - name: Push Git tag if it is new
        if: steps.version.outputs.tag != ''
        run: |
          TAG=${{ steps.version.outputs.tag }}
          echo "Using tag: $TAG"
          # Only create tag if the commit was fix/feat/feat!
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists, skipping creation."
          else
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git tag $TAG
            git push origin $TAG
            echo "âœ… Created and pushed tag: $TAG"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}