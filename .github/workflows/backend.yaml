name: CI/CD Backend

on:
  push:
    paths:
      - "backend/**"
      - ".github/workflows/backend.yaml"
    branches: [main]
  pull_request:
    paths:
      - "backend/**"
      - ".github/workflows/backend.yaml"
    branches: [main]

env:
  SERVICE_NAME: backend
  DOCKER_IMAGE: ${{ secrets.DOCKER_USERNAME }}/samsar

jobs:
  CI_CD_Backend:
    runs-on: ubuntu-latest
  
    steps:
      - name: checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Important: fetch all tags

      - name: Get version from Git tags
        id: version
        run: |
          # Fetch latest tags
          git fetch --tags

          # Get latest tag for this service
          LATEST_TAG=$(git tag -l "${SERVICE_NAME}-v*" | sort -V | tail -n1)
          if [ -z "$LATEST_TAG" ]; then
            VERSION="0.0.0"
            TAG="${SERVICE_NAME}-v$VERSION"
            echo "No existing tags found, starting at $VERSION"
          else
            # Extract version numbers
            VERSION="${LATEST_TAG#${SERVICE_NAME}-v}"
            TAG="$LATEST_TAG"
            echo "Latest tag found: $TAG"
          fi

          # Parse version into MAJOR.MINOR.PATCH
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # Get last commit message
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "Commit message: $COMMIT_MSG"

          # Decide if bump is needed
          if echo "$COMMIT_MSG" | grep -qiE '^feat!:|BREAKING CHANGE:'; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            TAG="${SERVICE_NAME}-v${NEW_VERSION}"
            echo "ðŸš€ Breaking change, bumping MAJOR to $NEW_VERSION"
          elif echo "$COMMIT_MSG" | grep -qiE '^feat:'; then
            MINOR=$((MINOR + 1))
            PATCH=0
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            TAG="${SERVICE_NAME}-v${NEW_VERSION}"
            echo "âœ¨ New feature, bumping MINOR to $NEW_VERSION"
          elif echo "$COMMIT_MSG" | grep -qiE '^fix:'; then
            PATCH=$((PATCH + 1))
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            TAG="${SERVICE_NAME}-v${NEW_VERSION}"
            echo "ðŸ› Bug fix, bumping PATCH to $NEW_VERSION"
          else
            # No bump, keep latest tag
            NEW_VERSION="$VERSION"
            echo "No version bump, keeping tag $TAG"
          fi

          # Set outputs for later steps
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_ENV
          echo $TAG

      - name: Create and push Git tag
        if: steps.version.outputs.tag != ''
        run: |
          echo "$TAG ***** $tag *** tag****"
          # # Only create tag if the commit was fix/feat/feat!
          # if git rev-parse "$TAG" >/dev/null 2>&1; then
          #   echo "Tag $TAG already exists, skipping creation."
          # else
          #   git config user.name "github-actions[bot]"
          #   git config user.email "github-actions[bot]@users.noreply.github.com"
          #   git tag $TAG
          #   git push origin $TAG
          #   echo "****$TAG"
          #   echo "****$tag"
          #   echo "âœ… Created and pushed tag: $TAG"
          # fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}



      - name: setup node js
        uses: actions/setup-node@v4
        with:
          node-version: 18
          
      - name: install dependencies
        run: |
          cd backend
          npm install
          
      - name: run tests
        run: |
          cd backend
          npm test
          
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
          
      - name: build and push backend image to docker hub
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/samsar:backend-${{ steps.version.outputs.version }}




      ###!!!!!!!!!!!!!only when feat fix BREAKING CHANGE
      # - name: Deploy to Render
      #   run: |
      #     curl -X POST https://api.render.com/deploy/srv-d5j7lp0gjchc73d0060g \
      #     -H "Accept: application/json" \
      #     -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}"

# Push to main
#    â†“
# Checkout code
#    â†“
# Install dependencies
#    â†“
# Run Jest tests
#    â†“
# Tests pass?
#    â”œâ”€â”€ NO â†’ Stop
#    â””â”€â”€ YES
#          â†“
#      Build Docker image
#          â†“
#      Push image to Docker Hub
#          â†“
#      Deploy on render
#

# B. Continuous Integration (CI) â€” Testing & Validation

# Ensure the code works and is high quality before deployment.

# Common steps:

# Checkout code (clone the repo)

# Set up environment (Node.js, Python, Java, etc.)

# Install dependencies

# Run tests (unit, integration, end-to-end)

# Optional:

# Linting / code formatting check

# Static type checks (TypeScript)

# Security audit (npm audit)

# Test coverage check

# âœ… Goal: catch issues early.

# C. Continuous Delivery / Deployment (CD) â€” Build & Deploy

# Get the code live automatically if CI passes.

# Common steps:

# Build artifacts (Docker image, binary, zip, etc.)

# Tag version (semantic version + commit SHA)

# Push artifact (Docker registry, package manager)

# Deploy to target environment:

# Cloud service (Render, Railway, Fly.io)

# Kubernetes cluster

# Serverless platform
